name: CI/CD Pipeline (Environment-Aware)

on:
  push:
    branches: [develop, main]
  pull_request:
    branches: [develop, main]

env:
  NODE_VERSION: '18'
  AWS_REGION: 'us-east-1'

permissions:
  id-token: write   # Required for JWT token handling and OIDC authentication
  contents: read    # Required for repository checkout operations

jobs:
  # Environment Detection Job
  setup:
    name: Environment Setup
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      tf_workspace: ${{ steps.env.outputs.tf_workspace }}
      instance_type: ${{ steps.env.outputs.instance_type }}
      min_instances: ${{ steps.env.outputs.min_instances }}
      max_instances: ${{ steps.env.outputs.max_instances }}
      run_full_tests: ${{ steps.env.outputs.run_full_tests }}
    
    steps:
      - name: Determine Environment Configuration
        id: env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "tf_workspace=production" >> $GITHUB_OUTPUT
            echo "instance_type=t3.medium" >> $GITHUB_OUTPUT
            echo "min_instances=2" >> $GITHUB_OUTPUT
            echo "max_instances=10" >> $GITHUB_OUTPUT
            echo "run_full_tests=true" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/develop" ]]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "tf_workspace=staging" >> $GITHUB_OUTPUT
            echo "instance_type=t3.micro" >> $GITHUB_OUTPUT
            echo "min_instances=1" >> $GITHUB_OUTPUT
            echo "max_instances=3" >> $GITHUB_OUTPUT
            echo "run_full_tests=false" >> $GITHUB_OUTPUT
          else
            echo "environment=review" >> $GITHUB_OUTPUT
            echo "tf_workspace=review" >> $GITHUB_OUTPUT
            echo "instance_type=t3.micro" >> $GITHUB_OUTPUT
            echo "min_instances=1" >> $GITHUB_OUTPUT
            echo "max_instances=1" >> $GITHUB_OUTPUT
            echo "run_full_tests=false" >> $GITHUB_OUTPUT
          fi

      - name: Display Environment Configuration
        run: |
          echo "🎯 Target Environment: ${{ steps.env.outputs.environment }}"
          echo "📦 Terraform Workspace: ${{ steps.env.outputs.tf_workspace }}"
          echo "💻 Instance Type: ${{ steps.env.outputs.instance_type }}"
          echo "📊 Instance Range: ${{ steps.env.outputs.min_instances }}-${{ steps.env.outputs.max_instances }}"
          echo "🧪 Full Test Suite: ${{ steps.env.outputs.run_full_tests }}"

  # Testing Job (Environment-Aware)
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: setup
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'app/package-lock.json'

      - name: Install dependencies
        run: |
          cd app
          npm ci

      - name: Run unit tests
        run: |
          cd app
          npm run test:unit

      - name: Run full integration tests (production)
        if: needs.setup.outputs.run_full_tests == 'true'
        run: |
          cd app
          npm run test:integration

      - name: Run basic integration tests (staging)
        if: needs.setup.outputs.run_full_tests == 'false' && needs.setup.outputs.environment == 'staging'
        run: |
          cd app
          npm run test:integration -- --testNamePattern="basic"

      - name: Upload test coverage (production only)
        if: needs.setup.outputs.run_full_tests == 'true'
        uses: codecov/codecov-action@v3
        with:
          file: ./app/coverage/lcov.info
          flags: unittests
          name: codecov-umbrella

  # Build Job
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [setup, test]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'app/package-lock.json'

      - name: Install dependencies
        run: |
          cd app
          npm ci

      - name: Build application
        run: |
          cd app
          npm run build

      - name: Create deployment package
        run: |
          cd app
          tar -czf ../deployment-${{ github.sha }}.tar.gz .
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: GitHubActions-Build-${{ needs.setup.outputs.environment }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Upload artifacts to S3
        run: |
          aws s3 cp deployment-${{ github.sha }}.tar.gz s3://aws-infra-demo-artifacts/builds/deployment-${{ github.sha }}.tar.gz

  # Unified Deployment Job (Environment-Aware)
  deploy:
    name: Deploy to ${{ needs.setup.outputs.environment }}
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: github.event_name == 'push' && (github.ref == 'refs/heads/develop' || github.ref == 'refs/heads/main')
    environment: 
      name: ${{ needs.setup.outputs.environment }}
      url: ${{ steps.deploy.outputs.app_url }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          role-session-name: GitHubActions-${{ needs.setup.outputs.environment }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0

      - name: Create environment-specific Terraform variables
        run: |
          cd infrastructure/environments/${{ needs.setup.outputs.tf_workspace }}
          
          # Create terraform.auto.tfvars with environment-specific values
          cat > terraform.auto.tfvars << EOF
          instance_type = "${{ needs.setup.outputs.instance_type }}"
          min_size = ${{ needs.setup.outputs.min_instances }}
          max_size = ${{ needs.setup.outputs.max_instances }}
          environment = "${{ needs.setup.outputs.environment }}"
          
          # Environment-specific tags
          tags = {
            Environment = "${{ needs.setup.outputs.environment }}"
            DeployedBy = "github-actions"
            GitSHA = "${{ github.sha }}"
            GitRef = "${{ github.ref_name }}"
          }
          EOF

      - name: Terraform Init
        run: |
          cd infrastructure/environments/${{ needs.setup.outputs.tf_workspace }}
          terraform init

      - name: Terraform Plan
        run: |
          cd infrastructure/environments/${{ needs.setup.outputs.tf_workspace }}
          terraform plan -out=tfplan

      - name: Terraform Apply
        run: |
          cd infrastructure/environments/${{ needs.setup.outputs.tf_workspace }}
          terraform apply -auto-approve tfplan

      - name: Deploy application
        id: deploy
        run: |
          # Download deployment package
          aws s3 cp s3://aws-infra-demo-artifacts/builds/deployment-${{ github.sha }}.tar.gz .
          
          # Deploy to instances
          ./scripts/deploy.sh ${{ needs.setup.outputs.environment }} ${{ github.sha }}
          
          # Get ALB URL for environment
          ALB_URL=$(cd infrastructure/environments/${{ needs.setup.outputs.tf_workspace }} && terraform output -raw alb_dns_name)
          echo "app_url=https://$ALB_URL" >> $GITHUB_OUTPUT

      - name: Create deployment metadata
        run: |
          ./scripts/deployment-metadata.sh create \
            -e ${{ needs.setup.outputs.environment }} \
            -v "${{ github.ref_name }}" \
            -s "${{ github.sha }}" \
            -a "builds/deployment-${{ github.sha }}.tar.gz" \
            -t pending

      - name: Run comprehensive smoke tests (production)
        if: needs.setup.outputs.run_full_tests == 'true'
        run: |
          cd app
          npm run test:smoke -- --env=${{ needs.setup.outputs.environment }}

      - name: Run basic smoke tests (staging)
        if: needs.setup.outputs.run_full_tests == 'false'
        run: |
          cd app
          npm run test:smoke -- --env=${{ needs.setup.outputs.environment }} --testNamePattern="critical"

      - name: Update deployment status to success
        if: success()
        run: |
          ./scripts/deployment-metadata.sh update \
            -e ${{ needs.setup.outputs.environment }} \
            -v "${{ github.ref_name }}" \
            -t success

      - name: Update deployment status to failed
        if: failure()
        run: |
          ./scripts/deployment-metadata.sh update \
            -e ${{ needs.setup.outputs.environment }} \
            -v "${{ github.ref_name }}" \
            -t failed

      - name: Trigger automatic rollback (staging only)
        if: failure() && needs.setup.outputs.environment == 'staging'
        run: |
          echo "🚨 Staging deployment failed, initiating automatic rollback..."
          
          curl -X POST \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/rollback.yml/dispatches \
            -d '{
              "ref": "${{ github.ref }}",
              "inputs": {
                "environment": "${{ needs.setup.outputs.environment }}",
                "trigger_reason": "deployment_failure",
                "failed_version": "${{ github.ref_name }}"
              }
            }' || echo "Failed to trigger automatic rollback workflow"

      - name: Notify production failure (manual rollback required)
        if: failure() && needs.setup.outputs.environment == 'production'
        run: |
          echo "🚨 Production deployment failed!"
          echo "⚠️  Manual rollback decision required."
          echo "🔧 Use: gh workflow run rollback.yml -f environment=production"
          echo "🔧 Or: ./scripts/rollback.sh -e production"

  # Notification Job
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [setup, deploy]
    if: always() && (needs.deploy.result == 'success' || needs.deploy.result == 'failure')
    
    steps:
      - name: Notify deployment result
        run: |
          if [[ "${{ needs.deploy.result }}" == "success" ]]; then
            echo "✅ Deployment to ${{ needs.setup.outputs.environment }} successful!"
            echo "🔗 Application URL: ${{ needs.deploy.outputs.app_url }}"
            echo "🎯 Environment: ${{ needs.setup.outputs.environment }}"
            echo "💻 Instance Type: ${{ needs.setup.outputs.instance_type }}"
            echo "📊 Instances: ${{ needs.setup.outputs.min_instances }}-${{ needs.setup.outputs.max_instances }}"
          else
            echo "❌ Deployment to ${{ needs.setup.outputs.environment }} failed!"
            if [[ "${{ needs.setup.outputs.environment }}" == "staging" ]]; then
              echo "🔄 Automatic rollback initiated"
            else
              echo "⚠️  Manual intervention required for production"
            fi
          fi
